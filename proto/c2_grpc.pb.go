// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             v3.21.12
// source: proto/c2.proto

package proto

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	C2Service_Register_FullMethodName           = "/c2.C2Service/Register"
	C2Service_BeaconStream_FullMethodName       = "/c2.C2Service/BeaconStream"
	C2Service_UploadFile_FullMethodName         = "/c2.C2Service/UploadFile"
	C2Service_DownloadFile_FullMethodName       = "/c2.C2Service/DownloadFile"
	C2Service_GetTasks_FullMethodName           = "/c2.C2Service/GetTasks"
	C2Service_SubmitResult_FullMethodName       = "/c2.C2Service/SubmitResult"
	C2Service_ListSessions_FullMethodName       = "/c2.C2Service/ListSessions"
	C2Service_DeleteSession_FullMethodName      = "/c2.C2Service/DeleteSession"
	C2Service_SendCommand_FullMethodName        = "/c2.C2Service/SendCommand"
	C2Service_GetCommandResult_FullMethodName   = "/c2.C2Service/GetCommandResult"
	C2Service_ListCommands_FullMethodName       = "/c2.C2Service/ListCommands"
	C2Service_PTYStream_FullMethodName          = "/c2.C2Service/PTYStream"
	C2Service_AddListener_FullMethodName        = "/c2.C2Service/AddListener"
	C2Service_ListListeners_FullMethodName      = "/c2.C2Service/ListListeners"
	C2Service_RemoveListener_FullMethodName     = "/c2.C2Service/RemoveListener"
	C2Service_GenerateImplant_FullMethodName    = "/c2.C2Service/GenerateImplant"
	C2Service_ListImplantBuilds_FullMethodName  = "/c2.C2Service/ListImplantBuilds"
	C2Service_SessionEventStream_FullMethodName = "/c2.C2Service/SessionEventStream"
)

// C2ServiceClient is the client API for C2Service service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// C2 Service Definition
type C2ServiceClient interface {
	// Initial implant registration
	Register(ctx context.Context, in *RegistrationRequest, opts ...grpc.CallOption) (*RegistrationResponse, error)
	// Bidirectional streaming for real-time communication
	BeaconStream(ctx context.Context, opts ...grpc.CallOption) (grpc.BidiStreamingClient[BeaconMessage, CommandMessage], error)
	// File upload/download operations
	UploadFile(ctx context.Context, opts ...grpc.CallOption) (grpc.ClientStreamingClient[FileChunk, FileResponse], error)
	DownloadFile(ctx context.Context, in *FileRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[FileChunk], error)
	// Task management
	GetTasks(ctx context.Context, in *TaskRequest, opts ...grpc.CallOption) (*TaskResponse, error)
	SubmitResult(ctx context.Context, in *TaskResult, opts ...grpc.CallOption) (*TaskAck, error)
	// Console/Admin operations
	ListSessions(ctx context.Context, in *SessionListRequest, opts ...grpc.CallOption) (*SessionListResponse, error)
	DeleteSession(ctx context.Context, in *SessionDeleteRequest, opts ...grpc.CallOption) (*SessionDeleteResponse, error)
	SendCommand(ctx context.Context, in *SendCommandRequest, opts ...grpc.CallOption) (*SendCommandResponse, error)
	GetCommandResult(ctx context.Context, in *CommandResultRequest, opts ...grpc.CallOption) (*CommandResultResponse, error)
	ListCommands(ctx context.Context, in *CommandListRequest, opts ...grpc.CallOption) (*CommandListResponse, error)
	// PTY streaming for interactive shells
	PTYStream(ctx context.Context, opts ...grpc.CallOption) (grpc.BidiStreamingClient[PTYClientMessage, PTYServerMessage], error)
	// Listener management
	AddListener(ctx context.Context, in *ListenerAddRequest, opts ...grpc.CallOption) (*ListenerAddResponse, error)
	ListListeners(ctx context.Context, in *ListenerListRequest, opts ...grpc.CallOption) (*ListenerListResponse, error)
	RemoveListener(ctx context.Context, in *ListenerRemoveRequest, opts ...grpc.CallOption) (*ListenerRemoveResponse, error)
	// Implant generation
	GenerateImplant(ctx context.Context, in *ImplantGenerationRequest, opts ...grpc.CallOption) (*ImplantGenerationResponse, error)
	// Implant build tracking
	ListImplantBuilds(ctx context.Context, in *ImplantBuildsListRequest, opts ...grpc.CallOption) (*ImplantBuildsListResponse, error)
	// Session event streaming for real-time console notifications
	SessionEventStream(ctx context.Context, in *SessionEventStreamRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[SessionEvent], error)
}

type c2ServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewC2ServiceClient(cc grpc.ClientConnInterface) C2ServiceClient {
	return &c2ServiceClient{cc}
}

func (c *c2ServiceClient) Register(ctx context.Context, in *RegistrationRequest, opts ...grpc.CallOption) (*RegistrationResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RegistrationResponse)
	err := c.cc.Invoke(ctx, C2Service_Register_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *c2ServiceClient) BeaconStream(ctx context.Context, opts ...grpc.CallOption) (grpc.BidiStreamingClient[BeaconMessage, CommandMessage], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &C2Service_ServiceDesc.Streams[0], C2Service_BeaconStream_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[BeaconMessage, CommandMessage]{ClientStream: stream}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type C2Service_BeaconStreamClient = grpc.BidiStreamingClient[BeaconMessage, CommandMessage]

func (c *c2ServiceClient) UploadFile(ctx context.Context, opts ...grpc.CallOption) (grpc.ClientStreamingClient[FileChunk, FileResponse], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &C2Service_ServiceDesc.Streams[1], C2Service_UploadFile_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[FileChunk, FileResponse]{ClientStream: stream}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type C2Service_UploadFileClient = grpc.ClientStreamingClient[FileChunk, FileResponse]

func (c *c2ServiceClient) DownloadFile(ctx context.Context, in *FileRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[FileChunk], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &C2Service_ServiceDesc.Streams[2], C2Service_DownloadFile_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[FileRequest, FileChunk]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type C2Service_DownloadFileClient = grpc.ServerStreamingClient[FileChunk]

func (c *c2ServiceClient) GetTasks(ctx context.Context, in *TaskRequest, opts ...grpc.CallOption) (*TaskResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(TaskResponse)
	err := c.cc.Invoke(ctx, C2Service_GetTasks_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *c2ServiceClient) SubmitResult(ctx context.Context, in *TaskResult, opts ...grpc.CallOption) (*TaskAck, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(TaskAck)
	err := c.cc.Invoke(ctx, C2Service_SubmitResult_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *c2ServiceClient) ListSessions(ctx context.Context, in *SessionListRequest, opts ...grpc.CallOption) (*SessionListResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SessionListResponse)
	err := c.cc.Invoke(ctx, C2Service_ListSessions_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *c2ServiceClient) DeleteSession(ctx context.Context, in *SessionDeleteRequest, opts ...grpc.CallOption) (*SessionDeleteResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SessionDeleteResponse)
	err := c.cc.Invoke(ctx, C2Service_DeleteSession_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *c2ServiceClient) SendCommand(ctx context.Context, in *SendCommandRequest, opts ...grpc.CallOption) (*SendCommandResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SendCommandResponse)
	err := c.cc.Invoke(ctx, C2Service_SendCommand_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *c2ServiceClient) GetCommandResult(ctx context.Context, in *CommandResultRequest, opts ...grpc.CallOption) (*CommandResultResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CommandResultResponse)
	err := c.cc.Invoke(ctx, C2Service_GetCommandResult_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *c2ServiceClient) ListCommands(ctx context.Context, in *CommandListRequest, opts ...grpc.CallOption) (*CommandListResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CommandListResponse)
	err := c.cc.Invoke(ctx, C2Service_ListCommands_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *c2ServiceClient) PTYStream(ctx context.Context, opts ...grpc.CallOption) (grpc.BidiStreamingClient[PTYClientMessage, PTYServerMessage], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &C2Service_ServiceDesc.Streams[3], C2Service_PTYStream_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[PTYClientMessage, PTYServerMessage]{ClientStream: stream}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type C2Service_PTYStreamClient = grpc.BidiStreamingClient[PTYClientMessage, PTYServerMessage]

func (c *c2ServiceClient) AddListener(ctx context.Context, in *ListenerAddRequest, opts ...grpc.CallOption) (*ListenerAddResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListenerAddResponse)
	err := c.cc.Invoke(ctx, C2Service_AddListener_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *c2ServiceClient) ListListeners(ctx context.Context, in *ListenerListRequest, opts ...grpc.CallOption) (*ListenerListResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListenerListResponse)
	err := c.cc.Invoke(ctx, C2Service_ListListeners_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *c2ServiceClient) RemoveListener(ctx context.Context, in *ListenerRemoveRequest, opts ...grpc.CallOption) (*ListenerRemoveResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListenerRemoveResponse)
	err := c.cc.Invoke(ctx, C2Service_RemoveListener_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *c2ServiceClient) GenerateImplant(ctx context.Context, in *ImplantGenerationRequest, opts ...grpc.CallOption) (*ImplantGenerationResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ImplantGenerationResponse)
	err := c.cc.Invoke(ctx, C2Service_GenerateImplant_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *c2ServiceClient) ListImplantBuilds(ctx context.Context, in *ImplantBuildsListRequest, opts ...grpc.CallOption) (*ImplantBuildsListResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ImplantBuildsListResponse)
	err := c.cc.Invoke(ctx, C2Service_ListImplantBuilds_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *c2ServiceClient) SessionEventStream(ctx context.Context, in *SessionEventStreamRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[SessionEvent], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &C2Service_ServiceDesc.Streams[4], C2Service_SessionEventStream_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[SessionEventStreamRequest, SessionEvent]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type C2Service_SessionEventStreamClient = grpc.ServerStreamingClient[SessionEvent]

// C2ServiceServer is the server API for C2Service service.
// All implementations must embed UnimplementedC2ServiceServer
// for forward compatibility.
//
// C2 Service Definition
type C2ServiceServer interface {
	// Initial implant registration
	Register(context.Context, *RegistrationRequest) (*RegistrationResponse, error)
	// Bidirectional streaming for real-time communication
	BeaconStream(grpc.BidiStreamingServer[BeaconMessage, CommandMessage]) error
	// File upload/download operations
	UploadFile(grpc.ClientStreamingServer[FileChunk, FileResponse]) error
	DownloadFile(*FileRequest, grpc.ServerStreamingServer[FileChunk]) error
	// Task management
	GetTasks(context.Context, *TaskRequest) (*TaskResponse, error)
	SubmitResult(context.Context, *TaskResult) (*TaskAck, error)
	// Console/Admin operations
	ListSessions(context.Context, *SessionListRequest) (*SessionListResponse, error)
	DeleteSession(context.Context, *SessionDeleteRequest) (*SessionDeleteResponse, error)
	SendCommand(context.Context, *SendCommandRequest) (*SendCommandResponse, error)
	GetCommandResult(context.Context, *CommandResultRequest) (*CommandResultResponse, error)
	ListCommands(context.Context, *CommandListRequest) (*CommandListResponse, error)
	// PTY streaming for interactive shells
	PTYStream(grpc.BidiStreamingServer[PTYClientMessage, PTYServerMessage]) error
	// Listener management
	AddListener(context.Context, *ListenerAddRequest) (*ListenerAddResponse, error)
	ListListeners(context.Context, *ListenerListRequest) (*ListenerListResponse, error)
	RemoveListener(context.Context, *ListenerRemoveRequest) (*ListenerRemoveResponse, error)
	// Implant generation
	GenerateImplant(context.Context, *ImplantGenerationRequest) (*ImplantGenerationResponse, error)
	// Implant build tracking
	ListImplantBuilds(context.Context, *ImplantBuildsListRequest) (*ImplantBuildsListResponse, error)
	// Session event streaming for real-time console notifications
	SessionEventStream(*SessionEventStreamRequest, grpc.ServerStreamingServer[SessionEvent]) error
	mustEmbedUnimplementedC2ServiceServer()
}

// UnimplementedC2ServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedC2ServiceServer struct{}

func (UnimplementedC2ServiceServer) Register(context.Context, *RegistrationRequest) (*RegistrationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Register not implemented")
}
func (UnimplementedC2ServiceServer) BeaconStream(grpc.BidiStreamingServer[BeaconMessage, CommandMessage]) error {
	return status.Errorf(codes.Unimplemented, "method BeaconStream not implemented")
}
func (UnimplementedC2ServiceServer) UploadFile(grpc.ClientStreamingServer[FileChunk, FileResponse]) error {
	return status.Errorf(codes.Unimplemented, "method UploadFile not implemented")
}
func (UnimplementedC2ServiceServer) DownloadFile(*FileRequest, grpc.ServerStreamingServer[FileChunk]) error {
	return status.Errorf(codes.Unimplemented, "method DownloadFile not implemented")
}
func (UnimplementedC2ServiceServer) GetTasks(context.Context, *TaskRequest) (*TaskResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetTasks not implemented")
}
func (UnimplementedC2ServiceServer) SubmitResult(context.Context, *TaskResult) (*TaskAck, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SubmitResult not implemented")
}
func (UnimplementedC2ServiceServer) ListSessions(context.Context, *SessionListRequest) (*SessionListResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListSessions not implemented")
}
func (UnimplementedC2ServiceServer) DeleteSession(context.Context, *SessionDeleteRequest) (*SessionDeleteResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteSession not implemented")
}
func (UnimplementedC2ServiceServer) SendCommand(context.Context, *SendCommandRequest) (*SendCommandResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SendCommand not implemented")
}
func (UnimplementedC2ServiceServer) GetCommandResult(context.Context, *CommandResultRequest) (*CommandResultResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetCommandResult not implemented")
}
func (UnimplementedC2ServiceServer) ListCommands(context.Context, *CommandListRequest) (*CommandListResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListCommands not implemented")
}
func (UnimplementedC2ServiceServer) PTYStream(grpc.BidiStreamingServer[PTYClientMessage, PTYServerMessage]) error {
	return status.Errorf(codes.Unimplemented, "method PTYStream not implemented")
}
func (UnimplementedC2ServiceServer) AddListener(context.Context, *ListenerAddRequest) (*ListenerAddResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddListener not implemented")
}
func (UnimplementedC2ServiceServer) ListListeners(context.Context, *ListenerListRequest) (*ListenerListResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListListeners not implemented")
}
func (UnimplementedC2ServiceServer) RemoveListener(context.Context, *ListenerRemoveRequest) (*ListenerRemoveResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RemoveListener not implemented")
}
func (UnimplementedC2ServiceServer) GenerateImplant(context.Context, *ImplantGenerationRequest) (*ImplantGenerationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GenerateImplant not implemented")
}
func (UnimplementedC2ServiceServer) ListImplantBuilds(context.Context, *ImplantBuildsListRequest) (*ImplantBuildsListResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListImplantBuilds not implemented")
}
func (UnimplementedC2ServiceServer) SessionEventStream(*SessionEventStreamRequest, grpc.ServerStreamingServer[SessionEvent]) error {
	return status.Errorf(codes.Unimplemented, "method SessionEventStream not implemented")
}
func (UnimplementedC2ServiceServer) mustEmbedUnimplementedC2ServiceServer() {}
func (UnimplementedC2ServiceServer) testEmbeddedByValue()                   {}

// UnsafeC2ServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to C2ServiceServer will
// result in compilation errors.
type UnsafeC2ServiceServer interface {
	mustEmbedUnimplementedC2ServiceServer()
}

func RegisterC2ServiceServer(s grpc.ServiceRegistrar, srv C2ServiceServer) {
	// If the following call pancis, it indicates UnimplementedC2ServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&C2Service_ServiceDesc, srv)
}

func _C2Service_Register_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RegistrationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(C2ServiceServer).Register(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: C2Service_Register_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(C2ServiceServer).Register(ctx, req.(*RegistrationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _C2Service_BeaconStream_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(C2ServiceServer).BeaconStream(&grpc.GenericServerStream[BeaconMessage, CommandMessage]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type C2Service_BeaconStreamServer = grpc.BidiStreamingServer[BeaconMessage, CommandMessage]

func _C2Service_UploadFile_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(C2ServiceServer).UploadFile(&grpc.GenericServerStream[FileChunk, FileResponse]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type C2Service_UploadFileServer = grpc.ClientStreamingServer[FileChunk, FileResponse]

func _C2Service_DownloadFile_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(FileRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(C2ServiceServer).DownloadFile(m, &grpc.GenericServerStream[FileRequest, FileChunk]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type C2Service_DownloadFileServer = grpc.ServerStreamingServer[FileChunk]

func _C2Service_GetTasks_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TaskRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(C2ServiceServer).GetTasks(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: C2Service_GetTasks_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(C2ServiceServer).GetTasks(ctx, req.(*TaskRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _C2Service_SubmitResult_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TaskResult)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(C2ServiceServer).SubmitResult(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: C2Service_SubmitResult_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(C2ServiceServer).SubmitResult(ctx, req.(*TaskResult))
	}
	return interceptor(ctx, in, info, handler)
}

func _C2Service_ListSessions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SessionListRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(C2ServiceServer).ListSessions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: C2Service_ListSessions_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(C2ServiceServer).ListSessions(ctx, req.(*SessionListRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _C2Service_DeleteSession_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SessionDeleteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(C2ServiceServer).DeleteSession(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: C2Service_DeleteSession_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(C2ServiceServer).DeleteSession(ctx, req.(*SessionDeleteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _C2Service_SendCommand_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SendCommandRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(C2ServiceServer).SendCommand(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: C2Service_SendCommand_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(C2ServiceServer).SendCommand(ctx, req.(*SendCommandRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _C2Service_GetCommandResult_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CommandResultRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(C2ServiceServer).GetCommandResult(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: C2Service_GetCommandResult_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(C2ServiceServer).GetCommandResult(ctx, req.(*CommandResultRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _C2Service_ListCommands_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CommandListRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(C2ServiceServer).ListCommands(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: C2Service_ListCommands_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(C2ServiceServer).ListCommands(ctx, req.(*CommandListRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _C2Service_PTYStream_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(C2ServiceServer).PTYStream(&grpc.GenericServerStream[PTYClientMessage, PTYServerMessage]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type C2Service_PTYStreamServer = grpc.BidiStreamingServer[PTYClientMessage, PTYServerMessage]

func _C2Service_AddListener_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListenerAddRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(C2ServiceServer).AddListener(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: C2Service_AddListener_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(C2ServiceServer).AddListener(ctx, req.(*ListenerAddRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _C2Service_ListListeners_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListenerListRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(C2ServiceServer).ListListeners(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: C2Service_ListListeners_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(C2ServiceServer).ListListeners(ctx, req.(*ListenerListRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _C2Service_RemoveListener_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListenerRemoveRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(C2ServiceServer).RemoveListener(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: C2Service_RemoveListener_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(C2ServiceServer).RemoveListener(ctx, req.(*ListenerRemoveRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _C2Service_GenerateImplant_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ImplantGenerationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(C2ServiceServer).GenerateImplant(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: C2Service_GenerateImplant_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(C2ServiceServer).GenerateImplant(ctx, req.(*ImplantGenerationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _C2Service_ListImplantBuilds_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ImplantBuildsListRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(C2ServiceServer).ListImplantBuilds(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: C2Service_ListImplantBuilds_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(C2ServiceServer).ListImplantBuilds(ctx, req.(*ImplantBuildsListRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _C2Service_SessionEventStream_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(SessionEventStreamRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(C2ServiceServer).SessionEventStream(m, &grpc.GenericServerStream[SessionEventStreamRequest, SessionEvent]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type C2Service_SessionEventStreamServer = grpc.ServerStreamingServer[SessionEvent]

// C2Service_ServiceDesc is the grpc.ServiceDesc for C2Service service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var C2Service_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "c2.C2Service",
	HandlerType: (*C2ServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Register",
			Handler:    _C2Service_Register_Handler,
		},
		{
			MethodName: "GetTasks",
			Handler:    _C2Service_GetTasks_Handler,
		},
		{
			MethodName: "SubmitResult",
			Handler:    _C2Service_SubmitResult_Handler,
		},
		{
			MethodName: "ListSessions",
			Handler:    _C2Service_ListSessions_Handler,
		},
		{
			MethodName: "DeleteSession",
			Handler:    _C2Service_DeleteSession_Handler,
		},
		{
			MethodName: "SendCommand",
			Handler:    _C2Service_SendCommand_Handler,
		},
		{
			MethodName: "GetCommandResult",
			Handler:    _C2Service_GetCommandResult_Handler,
		},
		{
			MethodName: "ListCommands",
			Handler:    _C2Service_ListCommands_Handler,
		},
		{
			MethodName: "AddListener",
			Handler:    _C2Service_AddListener_Handler,
		},
		{
			MethodName: "ListListeners",
			Handler:    _C2Service_ListListeners_Handler,
		},
		{
			MethodName: "RemoveListener",
			Handler:    _C2Service_RemoveListener_Handler,
		},
		{
			MethodName: "GenerateImplant",
			Handler:    _C2Service_GenerateImplant_Handler,
		},
		{
			MethodName: "ListImplantBuilds",
			Handler:    _C2Service_ListImplantBuilds_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "BeaconStream",
			Handler:       _C2Service_BeaconStream_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "UploadFile",
			Handler:       _C2Service_UploadFile_Handler,
			ClientStreams: true,
		},
		{
			StreamName:    "DownloadFile",
			Handler:       _C2Service_DownloadFile_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "PTYStream",
			Handler:       _C2Service_PTYStream_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "SessionEventStream",
			Handler:       _C2Service_SessionEventStream_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "proto/c2.proto",
}
